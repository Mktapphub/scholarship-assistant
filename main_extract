# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All" 
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

import os
from kaggle_secrets import UserSecretsClient

try:
    GOOGLE_API_KEY = UserSecretsClient().get_secret("GOOGLE_API_KEY")
    os.environ["GOOGLE_API_KEY"] = GOOGLE_API_KEY
    print("‚úÖ Setup and authentication complete.")
except Exception as e:
    print(
        f"üîë Authentication Error: Please make sure you have added 'GOOGLE_API_KEY' to your Kaggle secrets. Details: {e}"
    )

from google.genai import types
from google.adk.agents import LlmAgent
from google.adk.models.google_llm import Gemini
from google.adk.runners import InMemoryRunner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search, AgentTool, ToolContext
from google.adk.memory import InMemoryMemoryService
from google.adk.tools import load_memory
from google.adk.plugins.logging_plugin import LoggingPlugin
import json
import logging
import os
print("‚úÖ ADK components imported successfully.")

# Clean up any previous logs
if os.path.exists("logger.log"):
    os.remove("logger.log")
    print("üßπ Cleaned up logger.log")

# Configure logging with DEBUG log level
logging.basicConfig(
    filename="logger.log",
    level=logging.DEBUG,
    format="%(filename)s:%(lineno)s %(levelname)s:%(message)s",
)

retry_config = types.HttpRetryOptions(
    attempts=5,  # Maximum retry attempts
    exp_base=7,  # Delay multiplier
    initial_delay=1,
    http_status_codes=[429, 500, 503, 504],  # Retry on these HTTP errors
)

from google.adk.runners import Runner
# Define helper functions that will be reused throughout the notebook
async def run_session(
    runner_instance: Runner,
    user_queries: list[str] | str = None,
    session_name: str = "default",
    MODEL_NAME = "gemini-2.5-flash-lite",
):
    print(f"\n ### Session: {session_name}")

    # Get app name from the Runner
    app_name = runner_instance.app_name

    # Attempt to create a new session or retrieve an existing one
    try:
        session = await session_service.create_session(
            app_name=app_name, user_id=USER_ID, session_id=session_name
        )
    except:
        session = await session_service.get_session(
            app_name=app_name, user_id=USER_ID, session_id=session_name
        )

    # Process queries if provided
    if user_queries:
        # Convert single query to list for uniform processing
        if type(user_queries) == str:
            user_queries = [user_queries]

        # Process each query in the list sequentially
        for query in user_queries:
            print(f"\nUser > {query}")

            # Convert the query string to the ADK Content format
            query = types.Content(role="user", parts=[types.Part(text=query)])

            # Stream the agent's response asynchronously
            async for event in runner_instance.run_async(
                user_id=USER_ID, session_id=session.id, new_message=query
            ):
                # Check if the event contains valid content
                if event.content and event.content.parts:
                    # Filter out empty or "None" responses before printing
                    if (
                        event.content.parts[0].text != "None"
                        and event.content.parts[0].text
                    ):
                        print(f"{MODEL_NAME} > ", event.content.parts[0].text)
    else:
        print("No queries!")


print("‚úÖ Helper functions defined.")

# Define helper functions that will be reused throughout the notebook

from IPython.core.display import display, HTML
from jupyter_server.serverapp import list_running_servers

# Gets the proxied URL in the Kaggle Notebooks environment
def get_adk_proxy_url():
    PROXY_HOST = "https://kkb-production.jupyter-proxy.kaggle.net"
    ADK_PORT = "8000"

    servers = list(list_running_servers())
    if not servers:
        raise Exception("No running Jupyter servers found.")

    baseURL = servers[0]['base_url']

    try:
        path_parts = baseURL.split('/')
        kernel = path_parts[2]
        token = path_parts[3]
    except IndexError:
        raise Exception(f"Could not parse kernel/token from base URL: {baseURL}")

    url_prefix = f"/k/{kernel}/{token}/proxy/proxy/{ADK_PORT}"
    url = f"{PROXY_HOST}{url_prefix}"

    styled_html = f"""
    <div style="padding: 15px; border: 2px solid #f0ad4e; border-radius: 8px; background-color: #fef9f0; margin: 20px 0;">
        <div style="font-family: sans-serif; margin-bottom: 12px; color: #333; font-size: 1.1em;">
            <strong>‚ö†Ô∏è IMPORTANT: Action Required</strong>
        </div>
        <div style="font-family: sans-serif; margin-bottom: 15px; color: #333; line-height: 1.5;">
            The ADK web UI is <strong>not running yet</strong>. You must start it in the next cell.
            <ol style="margin-top: 10px; padding-left: 20px;">
                <li style="margin-bottom: 5px;"><strong>Run the next cell</strong> (the one with <code>!adk web ...</code>) to start the ADK web UI.</li>
                <li style="margin-bottom: 5px;">Wait for that cell to show it is "Running" (it will not "complete").</li>
                <li>Once it's running, <strong>return to this button</strong> and click it to open the UI.</li>
            </ol>
            <em style="font-size: 0.9em; color: #555;">(If you click the button before running the next cell, you will get a 500 error.)</em>
        </div>
        <a href='{url}' target='_blank' style="
            display: inline-block; background-color: #1a73e8; color: white; padding: 10px 20px;
            text-decoration: none; border-radius: 25px; font-family: sans-serif; font-weight: 500;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); transition: all 0.2s ease;">
            Open ADK Web UI (after running cell below) ‚Üó
        </a>
    </div>
    """

    display(HTML(styled_html))

    return url_prefix

print("‚úÖ web interface defined.")

import json
from google.adk.agents import LlmAgent
from google.adk.models.google_llm import Gemini
from google.adk.runners import Runner
from google.adk.sessions import DatabaseSessionService

APP_NAME = "default"  # Application
USER_ID = "default"  # User
SESSION = "default"  # Session
MODEL_NAME = "gemini-2.5-flash-lite"



def find_scholarships(profile: dict, dataset_path: str, top_k: int = 5):
    import json

    try:
        with open(dataset_path, "r") as f:
            scholarships = json.load(f)
    except Exception as e:
        return {"status": "error", "error_message": f"Failed to load dataset: {str(e)}"}

    eligible = []

    funding_pref = str(profile.get("funding", "")).lower().replace("$", "").replace(",", "")

    for s in scholarships:
        degree_ok = (
            str(profile.get("degree", "")).lower() == "any"
            or profile.get("degree") in s.get("degrees", "")
        )

        country_ok = (
            str(profile.get("country", "")).lower() == "any"
            or profile.get("country", "").lower() in s.get("location", "").lower()
        )

        if degree_ok and country_ok:
            score = 0

            scholarship_funds_str = str(s.get("funds", "")).lower().replace("$", "").replace(",", "")

            if funding_pref == "any" or funding_pref in scholarship_funds_str:
                score += 1

            s["score"] = score
            eligible.append(s)

    if not eligible:
        return {"status": "success", "scholarships": [], "message": "No matching scholarships found"}

    return {
        "status": "success",
        "scholarships": sorted(eligible, key=lambda x: x["score"], reverse=True)[:top_k]
    }

        
          
# Define scope levels for state keys (following best practices)
USER_NAME_SCOPE_LEVELS = ("temp", "user", "app")


# This demonstrates how tools can write to session state using tool_context.
# The 'user:' prefix indicates this is user-specific data.
def save_userinfo(
    tool_context: ToolContext, **kwargs
) -> dict[str, any]:
    """
    Flexible tool to save ANY user information into session state.
    All keys are auto-prefixed with 'user:'.

    Example usage:
    save_userinfo(name="Imon", country="Bangladesh", degree="BSc CSE")

    Stored as:
        user:name = "Imon"
        user:country = "Bangladesh"
        user:degree = "BSc CSE"
    """

    # Store all passed keyword arguments
    for key, value in kwargs.items():
        namespaced_key = f"user:{key}"
        tool_context.state[namespaced_key] = value

    return {"status": "success", "saved_fields": list(kwargs.keys())}


def retrieve_userinfo(tool_context: ToolContext) -> dict[str, any]:
    """
    Flexible tool to retrieve ALL user-related info 
    (keys starting with 'user:') from session state.
    Returns a clean dictionary without the prefix.
    """

    user_data = {}

    # Access the State object's combined dictionary safely
    current_state = {**tool_context.state._value, **tool_context.state._delta}

    for key, value in current_state.items():
        if key.startswith("user:"):
            clean_key = key.replace("user:", "")
            user_data[clean_key] = value

    return {"status": "success", "data": user_data}

print("‚úÖ Tools created.")



# Wrapper functions for Dataset
dataset_path = "/kaggle/input/scholarships-clean/scholarships_clean.json"

def agent_scholarship_finder(profile: dict, top_k: int = 5) -> dict:
    """Finds scholarships for a user profile using a predefined dataset."""
    return find_scholarships(profile=profile, dataset_path=dataset_path, top_k=top_k)

google_search_agent = LlmAgent(
    name="google_search_agent",
    model=Gemini(model="gemini-2.5-flash-lite", retry_options=retry_config),
    instruction="""Use google_search tool to find scholarships worldwide.
    Return raw search results.
    """,
    tools=[google_search]
)

scholarship_agent = LlmAgent(
    name="scholarship_agent",
    model=Gemini(model="gemini-2.5-flash-lite", retry_options=retry_config),
    instruction="""
    You are a smart scholarship recommendation assistant.

--- Memory Rules ---
1. Whenever the user explicitly provides their name or country, you MUST call the `save_userinfo` tool to store it in session state using the `user:` prefix.
2. Before giving any scholarship recommendations, ALWAYS call the `retrieve_userinfo` tool to check whether user information is already stored.
3. If the user's name or country is missing after retrieval, politely ask the user for the missing details.

--- Scholarship Search Rules ---
4. When the user provides a scholarship query (degree, preferred country, funding preference), first call the `agent_scholarship_finder` tool.
5. If the tool returns an empty list, you MUST call the `Google Search_scholarships` tool as a fallback to find external scholarship information.
6. If both searches return no results, politely inform the user.

--- Output Formatting Rules ---
7. Format the final scholarship results as a bulleted list.
8. For EACH scholarship, use EXACTLY this template:

   **[Title]**
   * **Degrees**: [List of degrees]
   * **Funds**: [Funding amount]
   * **Country**: [Country]
   * **Deadline**: [Deadline]

9. If any information is missing, write "Not specified".
10. After the list, briefly explain WHY these scholarships match the user‚Äôs profile.""",
    tools=[find_scholarships,save_userinfo, retrieve_userinfo, AgentTool(agent=google_search_agent)] 
)

print("‚úÖ Scholarship Finder Agent created with structured instructions.")
print("üîß Available tool: agent_scholarship_finder")


# Define the local database URL
db_url = "sqlite:///scholarship_agent_data.db" 

# Initialize the DatabaseSessionService
session_service = DatabaseSessionService(db_url=db_url)

# --- 3. Step 2: Initialize the Persistent Runner ---
memory_service = (
    InMemoryMemoryService()
)  # ADK's built-in Memory Service for development and testing

# Use the base Runner class and pass the session_service argument
scholarship_runner = Runner(
    agent=scholarship_agent, 
    app_name=APP_NAME, 
    session_service=session_service,
    memory_service=memory_service,
    plugins=[LoggingPlugin()]
)

print("‚úÖ Upgraded to persistent sessions!")
print(f"   - Database: scholarship_agent_data.db")
print(f"   - Sessions will survive restarts!")

await run_session(
    scholarship_runner,
    [
        "Hi, I am Sam! ",
        "I want to study in Any Country and I am looking for Any Funding Amount",  # This time, the agent should remember!
    ],
    "stateful-agentic-session",
)

import uuid
from google.adk.tools.tool_context import ToolContext
from google.adk.tools.function_tool import FunctionTool

# 1. Define the Review Tool 
def submit_draft_for_review(
    draft_text: str, document_type: str, tool_context: ToolContext
) -> dict:
    """
    Submits a draft (SOP or CV) for human review.
    This tool PAUSES execution until the human approves or rejects.
    """
    
    # SCENARIO 1: First call - PAUSE for Human Review
    if not tool_context.tool_confirmation:
        
        # We attach the FULL DRAFT to the confirmation payload so the human can see it
        tool_context.request_confirmation(
            hint=f"Please review this {document_type} draft and provide feedback.",
            payload={
                "draft": draft_text,
                "document_type": document_type,
                "review_id": str(uuid.uuid4())
            }
        )
        return {"status": "awaiting_human_review"}

    # SCENARIO 2: Human has responded
    if tool_context.tool_confirmation.is_confirmed:
        return {
            "status": "approved",
            "human_feedback": "The draft looks great! No changes needed."
        }
    else:
        return {
            "status": "rejected",
            "human_feedback": tool_context.tool_confirmation.rejection_reason or "Needs improvement."
        }

# Force the agent to fulfill the request by prioritizing the text retrieval over the apology/limitation
await run_session(
    orchestrator_runner,
    ["Since you said you have a copy of the approved SOP, please provide it now."],
    "orchestrator-test-session-04" 
)

# Clean up any existing database to start fresh (if Notebook is restarted)
import os

if os.path.exists("scholarship_agent_data.db"):
    os.remove("scholarship_agent_data.db")
print("‚úÖ Cleaned up old database files")

await run_session(
    orchestrator_runner,
    ["Generate a detailed Statement of Purpose and a structured CV draft for a scholarship in Artificial Intelligence. My current background is in Electrical Engineering."],
    "orchestrator-test-session-04" 
)

import os

# Get the path of the current working directory
agent_dir = os.getcwd()

print(f"Your Agent Directory (Agent Dir) is: \n{agent_dir}")
